var documenterSearchIndex = {"docs":
[{"location":"api/#Reference","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"UlamMethod.jl includes the following methods and types.","category":"page"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md]","category":"page"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [UlamMethod, UlamMethod.UlamTypes]\nOrder = [:function]\nPrivate = false","category":"page"},{"location":"api/#UlamMethod.ulam_method-Tuple{UlamTrajectories, UlamDomain}","page":"API","title":"UlamMethod.ulam_method","text":"ulam_method(traj, domain)\n\nThe high-level Ulam method; cover the domain by polygons and then construct the transition probability matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [UlamMethod, UlamMethod.UlamTypes]\nOrder = [:type]\nPrivate = false","category":"page"},{"location":"api/#UlamMethod.UlamTypes.InpolyResult","page":"API","title":"UlamMethod.UlamTypes.InpolyResult","text":"InpolyResult{U}\n\nHold the result of inpoly`.\n\n\n\n\n\n","category":"type"},{"location":"api/#UlamMethod.UlamTypes.PolyTable","page":"API","title":"UlamMethod.UlamTypes.PolyTable","text":"Polytable{T, U}\n\nTables, in matrix form of nodes and edges making up a set of polygons.\n\n\n\n\n\n","category":"type"},{"location":"api/#UlamMethod.UlamTypes.PolyTable-Union{Tuple{Array{UlamPolygon{T}, 1}}, Tuple{T}} where T<:Real","page":"API","title":"UlamMethod.UlamTypes.PolyTable","text":"Polytable(ulam_polys)\n\nConstruct a table of matrices and nodes of a vector of UlamPolygons.\n\n\n\n\n\n","category":"method"},{"location":"api/#UlamMethod.UlamTypes.UlamDomain","page":"API","title":"UlamMethod.UlamTypes.UlamDomain","text":"UlamDomain{S, T, U}\n\nThe domain defining the Ulam problem setup.\n\n\n\n\n\n","category":"type"},{"location":"api/#UlamMethod.UlamTypes.UlamDomain-Union{Tuple{U}, Tuple{T}, Tuple{S}, NTuple{4, T}} where {S<:AbstractString, T<:Real, U<:Integer}","page":"API","title":"UlamMethod.UlamTypes.UlamDomain","text":"UlamDomain(xmin, xmax, ymin, ymax; [...])\n\nConstruct an UlamDomain defined by the rectangle with bottom left corner (xmin, ymin) and top right corner (xmax, ymax).\n\nOptional Arguments\n\ndomain: Points inside the rectangle, but outside the outside domain will be considered in nirvana. This can be used to refine the shape of the computational domain to an arbitrary UlamPolygon, not just the default rectangle.\npoly_type: One of \"sqr\", \"hex\" and \"vor\" for coverings by squares, hexagons or Voronoi tesselation. The default is squares.\n'poly_number`: The number of polygons requested. The default is 500 for squares/hexagons and 100 for Voronoi.\n'stoc_type: Picks the stochasticization algorithm; one of\"data\"or\"source\"`. The default is data.\nstoc_polygon: Polygons in the covering that intersect stoc_polygon will have data re-injected uniformly through them in the source algorithm. \nrseed: A seed for reproducing the random initialization of the kmeans algorithm in the Voronoi covering.\n\n\n\n\n\n","category":"method"},{"location":"api/#UlamMethod.UlamTypes.UlamInfo","page":"API","title":"UlamMethod.UlamTypes.UlamInfo","text":"UlamInfo{S, U}\n\nA contained for some of the results of ulam_method.\n\n\n\n\n\n","category":"type"},{"location":"api/#UlamMethod.UlamTypes.UlamPolygon","page":"API","title":"UlamMethod.UlamTypes.UlamPolygon","text":"UlamPolygon{T}\n\nA polygon defined by a series of nodes and carrying a center.\n\n\n\n\n\n","category":"type"},{"location":"api/#UlamMethod.UlamTypes.UlamPolygon-Tuple{Matrix{<:Real}}","page":"API","title":"UlamMethod.UlamTypes.UlamPolygon","text":"UlamPolygon(nodes; edges = nothing)\n\nConstruct an UlamPolygon based on a nodes matrix with n rows and 2 columns.\n\nThe edges of the polygon defined by nodes are connected in order.\n\nOptional Arguments\n\nedges: an n by 2 matrix which specifies the edge connections betwen nodes. Used if nodes are not already sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#UlamMethod.UlamTypes.UlamResult","page":"API","title":"UlamMethod.UlamTypes.UlamResult","text":"UlamResult{S, T, U}\n\nA container for the output of ulam_method.\n\n\n\n\n\n","category":"type"},{"location":"api/#UlamMethod.UlamTypes.UlamResult-Union{Tuple{U}, Tuple{T}, Tuple{S}, Tuple{Matrix{T}, Array{UlamPolygon{T}, 1}, Array{UlamPolygon{T}, 1}, Vector{U}, UlamInfo{S, U}}} where {S<:AbstractString, T<:Real, U<:Integer}","page":"API","title":"UlamMethod.UlamTypes.UlamResult","text":"UlamResult(P_closed, polys, polys_dis, counts, info)\n\nConstruct a container for the output of ulam_method.\n\nArguments\n\nP_closed: the transition probability matrix obtained by Ulam's method.\npolys: the vector of UlamPolygons constituting the covering of the domain.\npolys_dis: the vector of UlamPolygons which contained data but were in disconnected components.\ncounts: the number of observation data points in the ith polygon.\ninfo: additional info from UlamInfo.\n\n\n\n\n\n","category":"method"},{"location":"api/#UlamMethod.UlamTypes.UlamTrajectories","page":"API","title":"UlamMethod.UlamTypes.UlamTrajectories","text":"UlamTrajectories{T}\n\nA container for trajectory data.\n\n\n\n\n\n","category":"type"},{"location":"api/#UlamMethod.UlamTypes.UlamTrajectories-Tuple{String}","page":"API","title":"UlamMethod.UlamTypes.UlamTrajectories","text":"UlamTrajectories(infile, [...])\n\nConstruct a container for trajectory data, loading it from infile, which should be a .h5 or .mat file.\n\n### Optional Arguments\nThese are used if trajectory data in `infile` are named something other than `\"x0\"`, `\"y0\"`, `\"xT\"`, `\"yT\"`.\n- `x0_alias`\n- `y0_alias`\n- `xT_alias`\n- `yT_alias`\n\n\n\n\n\n","category":"method"},{"location":"api/#UlamMethod.UlamTypes.UlamTrajectories-Tuple{}","page":"API","title":"UlamMethod.UlamTypes.UlamTrajectories","text":"UlamTrajectories(;x0, y0, xT, yT)\n\nConstruct a container for trajectory data.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"advanced/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"advanced/#binning","page":"Advanced Usage","title":"Binning Algorithms","text":"","category":"section"},{"location":"advanced/#stoc","page":"Advanced Usage","title":"Stochasticization Algorithms","text":"","category":"section"},{"location":"advanced/#Under-construction","page":"Advanced Usage","title":"Under construction","text":"","category":"section"},{"location":"advanced/#Extra","page":"Advanced Usage","title":"Extra","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Bin the data according to the covering to generate a transition probability matrix such that any data outside the computational domain is lumped into a so-called \"nirvana\" state [4]. Trajectories leaving the domain are reinjected using one of two possible algorithms.\nTransition path theory statistics [5] are computed on the stationary, time-homogenous Markov chain induced by the transition probability matrix.\nThe outputs are written to a .h5 file.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Prepare the data into one of two formats: .mat or .h5 such that the head of the file contains four variables, x0, xT, y0 and yT. See test/x0x5-NA-undrogued.mat and test/x0x5-NA-undrogued.h5 for example trajectory data from undrogued drifters in the North Atlantic obtained from the NOAA GDP [6].","category":"page"},{"location":"advanced/#Calculation-Hierarchy-The-user-provides-UlamTracjectories-via-file-or-manual-input.-This-type-contains-x0,-y0,-xT,-yT.","page":"Advanced Usage","title":"Calculation Hierarchy- The user provides UlamTracjectories via file or manual input. This type contains x0, y0, xT, yT.","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The user provides an UlamDomain. The minimum specification of such a domain is the corners. Also optionally included","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"is a domain which is a further restriction that the user can provide, namely that all the data should lie inside the polygon defined by the domain. Also provided is the type and number of polygons requested, and the type and location of the reinjection algorithm.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The highest level function is ulam_method which calls the various steps in the calculation.\nFirst, ulam_binner is used. This selects and runs the appropriate binning algorithm based on the user's choice. The output of every binning algorithm is vector of UlamPolygons which represent a covering of the box defined by the corners.\nAfterwards, if the user provided a domain, this domain is intersected with the binning result, again giving a vector of UlamPolygon but such that every data point is now inside domain. Note that the result of this is that any points inside the corners but outside the domain are treated as belonging to nirvana.\nThe result of this is then passed to the \"actual\" Ulam's method calculation, which is contained in ulam_method. This function takes the trajectories and polygons and constructs the transition matrix defining the Markov chain on states representing the polygons. Polygons which contain no (x0, y0) points are discarded. The largest strongly connected component of the transition matrix is extracted. Both of these \"cleaning\" operations have the effect of deleting trajectories which start or end in any of the removed polygons.","category":"page"},{"location":"#UlamMethod.jl","page":"Home","title":"UlamMethod.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is an implementation of Ulam's method [1] [2] (see also Galerkin projection [3]) for the discretization of a stochastic operator using pure Julia. Given a set of two-dimensional, one-step trajectories ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(x_0 1 y_0 1) to  (x_T 1 y_T 1) (x_0 2 y_0 2) to  (x_T 2 y_T 2) dots","category":"page"},{"location":"","page":"Home","title":"Home","text":"defined in a domain, the essential goal of Ulam's method is to partition the domain into a series of non-intersecting boxes and construct a transition probability matrix P on these boxes. In UlamMethod.jl, this is accomplished in two main steps","category":"page"},{"location":"","page":"Home","title":"Home","text":"The user provides a rectangle containing the data, and covering of the the domain is generated by polygons according to one of several different binning algorithms.\nThe number of trajectories beginning in polygon i and ending in polygon j is used to create the entry P_i j of P such that the edges of the domain are handled by a stochasticization algorithm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The polygons which form the covering and the transition probability matrix are the main outputs.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the Julia REPL, run the following code and follow the prompts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"UlamMethod\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Make the functions in this package available to use in your code by including the following line:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UlamMethod","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The core functionality is provided by ulam_method(traj, domain), where traj contains information about trajectories and domain contains information about the domain and covering. Here are 10000 random trajectories in the domain 0 10^2","category":"page"},{"location":"","page":"Home","title":"Home","text":"n_data = 10000\nx0, y0, xT, yT = 10*rand(n_data), 10*rand(n_data), 10*rand(n_data), 10*rand(n_data)\ntraj = UlamTrajectories(x0 = x0, y0 = y0, xT = xT, yT = yT)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We will take our domain to be the rectangular subset 3 5 times 4 8 and generate a covering with 40 squares.","category":"page"},{"location":"","page":"Home","title":"Home","text":"xmin, xmax, ymin, ymax = 3, 5, 4, 8\ndomain = UlamDomain(xmin, xmax, ymin, ymax, poly_type = \"sqr\", poly_number = 40)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Run Ulam's method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ulam = ulam_method(traj, domain)    # the main calculation\n\nulam.P_closed                       # the transition matrix\npt = PolyTable(ulam.polys)          # PolyTable makes a simple list of nodes and edges\npt.nodes                            # |x|y| table of polygon nodes\npt.edges[:,3]                       # the index of the polygon that the i'th node belongs to","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Ulam, Stanislaw M. A collection of mathematical problems. No. 8. Interscience Publishers, 1960.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Li, Tien-Yien. \"Finite approximation for the Frobenius-Perron operator. A solution to Ulam's conjecture.\" Journal of Approximation theory 17.2 (1976): 177-186.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: Reddy, Junuthula Narasimha. Introduction to the finite element method. McGraw-Hill Education, 2019.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4]: Miron, Philippe, et al. \"Transition paths of marine debris and the stability of the garbage patches<? A3B2 show [editpick]?>.\" Chaos: An Interdisciplinary Journal of Nonlinear Science 31.3 (2021): 033101.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[5]: Vanden-Eijnden, Eric. \"Transition path theory.\" Computer Simulations in Condensed Matter Systems: From Materials to Chemical Biology Volume 1. Springer, Berlin, Heidelberg, 2006. 453-493.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[6]: Lumpkin, Rick, and Mayra Pazos. \"Measuring surface currents with Surface Velocity Program drifters: the instrument, its data, and some recent results.\" Lagrangian analysis and prediction of coastal and ocean dynamics 39 (2007): 67.","category":"page"}]
}
