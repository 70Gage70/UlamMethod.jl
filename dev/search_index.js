var documenterSearchIndex = {"docs":
[{"location":"api/#Reference","page":"API","title":"Reference","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"UlamMethod.jl includes the following methods and types.","category":"page"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md]","category":"page"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [UlamMethod, UlamMethod.UlamTypes]\nOrder = [:function]\nPrivate = false","category":"page"},{"location":"api/#UlamMethod.ulam_method-Tuple{UlamTrajectories, UlamDomain}","page":"API","title":"UlamMethod.ulam_method","text":"ulam_method(traj, domain)\n\nRun the high-level Ulam method and return an UlamResult.\n\nArguments\n\ntraj: An UlamTrajectories; contains the trajectory data.\ndomain: An UlamDomain; contains the domain specification.\n\n\n\n\n\n","category":"method"},{"location":"api/#UlamMethod.ulam_write-Tuple{String, UlamResult}","page":"API","title":"UlamMethod.ulam_write","text":"ulam_write(outfile, ulam_result; P_out)\n\nWrite ulam_result to the file outfile, which must be in the .h5 format. \n\nOptional Arguments\n\nP_out: If false, P_closed` is not written to file since it can sometimes be very large. Default true.\n\n\n\n\n\n","category":"method"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [UlamMethod, UlamMethod.UlamTypes]\nOrder = [:type]\nPrivate = false","category":"page"},{"location":"api/#UlamMethod.UlamTypes.InpolyResult","page":"API","title":"UlamMethod.UlamTypes.InpolyResult","text":"InpolyResult{U}\n\nHold the result of inpoly.\n\n\n\n\n\n","category":"type"},{"location":"api/#UlamMethod.UlamTypes.PolyTable","page":"API","title":"UlamMethod.UlamTypes.PolyTable","text":"Polytable{T, U}\n\nTables, in matrix form of nodes and edges making up a set of polygons.\n\n\n\n\n\n","category":"type"},{"location":"api/#UlamMethod.UlamTypes.PolyTable-Union{Tuple{Array{UlamPolygon{T}, 1}}, Tuple{T}} where T<:Real","page":"API","title":"UlamMethod.UlamTypes.PolyTable","text":"Polytable(ulam_polys)\n\nConstruct a table of matrices and nodes of a vector of UlamPolygons.\n\n\n\n\n\n","category":"method"},{"location":"api/#UlamMethod.UlamTypes.UlamDomain","page":"API","title":"UlamMethod.UlamTypes.UlamDomain","text":"UlamDomain{S, T, U}\n\nThe domain defining the Ulam problem setup.\n\n\n\n\n\n","category":"type"},{"location":"api/#UlamMethod.UlamTypes.UlamDomain-Union{Tuple{U}, Tuple{T}, Tuple{S}, NTuple{4, T}} where {S<:AbstractString, T<:Real, U<:Integer}","page":"API","title":"UlamMethod.UlamTypes.UlamDomain","text":"UlamDomain(xmin, xmax, ymin, ymax; [...])\n\nConstruct an UlamDomain defined by the rectangle with bottom left corner (xmin, ymin) and top right corner (xmax, ymax).\n\nOptional Arguments\n\ndomain: Points inside the rectangle, but outside the outside domain will be considered in nirvana. This can be used to refine the shape of the computational domain to an arbitrary UlamPolygon, not just the default rectangle.\npoly_type: One of \"sqr\", \"hex\", and \"vor\" for coverings by squares, hexagons or Voronoi tesselation. The default is squares.\npoly_number: The number of polygons requested. The default is 500 for squares/hexagons and 100 for Voronoi.\nstoc_type: Picks the stochasticization algorithm; one of \"data\" or \"source\". The default is data.\nstoc_polygon: Polygons in the covering that intersect stoc_polygon will have data re-injected uniformly through them in the source algorithm. \nrseed: A seed for reproducing the random initialization of the kmeans algorithm in the Voronoi covering.\n\n\n\n\n\n","category":"method"},{"location":"api/#UlamMethod.UlamTypes.UlamInfo","page":"API","title":"UlamMethod.UlamTypes.UlamInfo","text":"UlamInfo{S, U}\n\nA contained for some of the results of ulam_method.\n\n\n\n\n\n","category":"type"},{"location":"api/#UlamMethod.UlamTypes.UlamPolygon","page":"API","title":"UlamMethod.UlamTypes.UlamPolygon","text":"UlamPolygon{T}\n\nA polygon defined by a series of nodes and carrying a center.\n\n\n\n\n\n","category":"type"},{"location":"api/#UlamMethod.UlamTypes.UlamPolygon-Tuple{Matrix{<:Real}}","page":"API","title":"UlamMethod.UlamTypes.UlamPolygon","text":"UlamPolygon(nodes; edges = nothing)\n\nConstruct an UlamPolygon based on a nodes matrix with n rows and 2 columns.\n\nThe edges of the polygon defined by nodes are connected in order.\n\nOptional Arguments\n\nedges: an n by 2 matrix which specifies the edge connections betwen nodes. Used if nodes are not already sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#UlamMethod.UlamTypes.UlamResult","page":"API","title":"UlamMethod.UlamTypes.UlamResult","text":"UlamResult{S, T, U}\n\nA container for the output of ulam_method.\n\n\n\n\n\n","category":"type"},{"location":"api/#UlamMethod.UlamTypes.UlamResult-Union{Tuple{U}, Tuple{T}, Tuple{S}, Tuple{Matrix{T}, Array{UlamPolygon{T}, 1}, Array{UlamPolygon{T}, 1}, Vector{U}, UlamInfo{S, U}}} where {S<:AbstractString, T<:Real, U<:Integer}","page":"API","title":"UlamMethod.UlamTypes.UlamResult","text":"UlamResult(P_closed, polys, polys_dis, counts, info)\n\nConstruct a container for the output of ulam_method.\n\nArguments\n\nP_closed: the transition probability matrix obtained by Ulam's method.\npolys: the vector of UlamPolygons constituting the covering of the domain.\npolys_dis: the vector of UlamPolygons which contained data but were in disconnected components.\ncounts: the number of observation data points in the ith polygon.\ninfo: additional info from UlamInfo.\n\n\n\n\n\n","category":"method"},{"location":"api/#UlamMethod.UlamTypes.UlamTrajectories","page":"API","title":"UlamMethod.UlamTypes.UlamTrajectories","text":"UlamTrajectories{T}\n\nA container for trajectory data.\n\n\n\n\n\n","category":"type"},{"location":"api/#UlamMethod.UlamTypes.UlamTrajectories-Tuple{String}","page":"API","title":"UlamMethod.UlamTypes.UlamTrajectories","text":"UlamTrajectories(infile, [...])\n\nConstruct a container for trajectory data, loading it from infile, which should be a .h5 or .mat file.\n\nOptional Arguments\n\nThese are used if trajectory data in infile are named something other than \"x0\", \"y0\", \"xT\", \"yT\".\n\nx0_alias\ny0_alias\nxT_alias\nyT_alias\n\n\n\n\n\n","category":"method"},{"location":"api/#UlamMethod.UlamTypes.UlamTrajectories-Tuple{}","page":"API","title":"UlamMethod.UlamTypes.UlamTrajectories","text":"UlamTrajectories(;x0, y0, xT, yT)\n\nConstruct a container for trajectory data.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"theory/#Theory-and-Implementation","page":"Theory and Implementation","title":"Theory and Implementation","text":"","category":"section"},{"location":"theory/","page":"Theory and Implementation","title":"Theory and Implementation","text":"UNDER CONSTRUCTION.","category":"page"},{"location":"theory/#Calculation-Hierarchy","page":"Theory and Implementation","title":"Calculation Hierarchy","text":"","category":"section"},{"location":"theory/","page":"Theory and Implementation","title":"Theory and Implementation","text":"The user provides UlamTracjectories via file or manual input. This type contains x0, y0, xT, yT.\nThe user provides an UlamDomain. The minimum specification of such a domain is the corners. Also optionally included","category":"page"},{"location":"theory/","page":"Theory and Implementation","title":"Theory and Implementation","text":"is a domain which is a further restriction that the user can provide, namely that all the data should lie inside the polygon defined by the domain. Also provided is the type and number of polygons requested, and the type and location of the reinjection algorithm.","category":"page"},{"location":"theory/","page":"Theory and Implementation","title":"Theory and Implementation","text":"The highest level function is ulam_method which calls the various steps in the calculation.\nFirst, ulam_binner is used. This selects and runs the appropriate binning algorithm based on the user's choice. The output of every binning algorithm is vector of UlamPolygons which represent a covering of the box defined by the corners.\nAfterwards, if the user provided a domain, this domain is intersected with the binning result, again giving a vector of UlamPolygon but such that every data point is now inside domain. Note that the result of this is that any points inside the corners but outside the domain are treated as belonging to nirvana.\nThe result of this is then passed to the \"actual\" Ulam's method calculation, which is contained in ulam_method. This function takes the trajectories and polygons and constructs the transition matrix defining the Markov chain on states representing the polygons. Polygons which contain no (x0, y0) points are discarded. The largest strongly connected component of the transition matrix is extracted. Both of these \"cleaning\" operations have the effect of deleting trajectories which start or end in any of the removed polygons.","category":"page"},{"location":"advanced/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"advanced/#Loading-trajectories","page":"Advanced Usage","title":"Loading trajectories","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The core functionality is provided by ","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"UlamTrajectories(infile; x0_alias, y0_alias, xT_alias, yT_alias)","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"For larger systems, trajectory data may be loaded from a file. This file should be in the .mat or .h5 format with the keys \"x0\", \"y0\", \"xT\" and \"xT\" in the root of the file. For this example, the file test/x0x5-NA-undrogued.h5 contains trajectory data from undrogued drifters in the North Atlantic obtained from the NOAA GDP [3].","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"infile = \"x0x5-NA-undrogued.h5\"     # place this file in your working directory, or define a path to it\ntraj = UlamTrajectories(infile)","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Alias for the trajectory data may be provided. For example, if we had a file in which the \"x0\" data were instead called \"xtraj0\", we could use traj = UlamTrajectories(infile, x0_alias = \"xtraj0\") and so on for other keys.","category":"page"},{"location":"advanced/#Defining-domains","page":"Advanced Usage","title":"Defining domains","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The core functionality is provided by ","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"UlamDomain(xmin, xmax, ymin, ymax; domain, poly_type, poly_number, stoc_type, stoc_polygon, rseed)","category":"page"},{"location":"advanced/#Refinement","page":"Advanced Usage","title":"Refinement","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The default behavior is that all data outside the computational rectangle are considered to be in nirvana. The core computatinal rectangle can be refined with the named argument domain. This should be a single UlamPolygon. The effect domain is that data points inside the rectangle but outside the domain are considered to be in nirvana. TODO: Add examples.","category":"page"},{"location":"advanced/#binning","page":"Advanced Usage","title":"Binning Algorithms","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"These algorithms control how the computational rectangle is covered in polygons. The named argument poly_type to UlamDomain can take one of three values:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"\"sqr\": A covering of the domain by a regular grid of squares (default.) This algorithm is suitable for trajectory data with few \"holes\" in the observations.\n\"hex\": A covering of the domain by a regular grid of hexagons. Hexagons may have some advantages over squares[1].\n\"vor\": A covering of the domain by a Voronoi tesselation generated by cluster centers obtained from k-means[2]. This algorithm is more appropriate for sparse data. Pass rseed for reproducible results; the kmeans initialization contains some randomness.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The named argument poly_number selects the number of polygons in each case.","category":"page"},{"location":"advanced/#stoc","page":"Advanced Usage","title":"Stochasticization Algorithms","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"These algorithms control how reinjection counts (trajectories pointing from nirvana to the interior) are distributed. The named argumet stoc_type to UlamDomain can take one of two values:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"\"data\": Reinjection occurs according to which boxes trajectories actually enter (this is the default algorithm.)\n\"source\": Reinjection occurs uniformly in polygons which intersect with the UlamPolygon in the named argument stoc_poly. If no stoc_poly is provided, reinjection occurs uniformly over the entire domai","category":"page"},{"location":"advanced/#Using-the-results","page":"Advanced Usage","title":"Using the results","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The core functionality is provided by ","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"ulam_method(traj, domain)","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The output of ulam_method is an UlamResult. This contains the main objects calculated by Ulam's Method.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"polys: A vector of UlamPolygons which define the covering. Use PolyTable to access the nodes in a readable format.\npolys_dis: A vector of UlamPolygons which contained data but were disconnected when the strongest connected component was calculated.\nP_closed: The full transition matrix. The last row and column correspond to nirvana.\npi_closed: The largest left eigenvector of P_closed.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"For convenience P_open and pi_open are also provided, which are identical to P_closed and pi_closed with the nirvana entries removed.","category":"page"},{"location":"advanced/#Writing-the-results","page":"Advanced Usage","title":"Writing the results","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"A custom write method is provided","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"ulam_write(outfile, ulam_result; P_out)","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"This will write an UlamResult to the file specified by outfile. Note that outfile must be of the form \"fname.h5\". Optionally pass P_out = false to avoid writing the P_closed matrix since it can be very large.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The polygons will be output in an N times 3 matrix such that the first two columns are the (x y) coordinates of a polygon vertex and the third column is the index of the polygon that vertex belongs to. The vertices are sorted. ","category":"page"},{"location":"advanced/#References","page":"Advanced Usage","title":"References","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"[1]: https://www.uber.com/blog/h3/","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"[2]: https://en.wikipedia.org/wiki/K-means_clustering","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"[3]: https://www.aoml.noaa.gov/phod/gdp/data.php","category":"page"},{"location":"#UlamMethod.jl","page":"Home","title":"UlamMethod.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is an implementation of Ulam's method [1] [2] (see also Galerkin projection [3]) for the discretization of a stochastic operator using pure Julia. Given a set of two-dimensional, one-step trajectories ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(x_0 1 y_0 1) to  (x_T 1 y_T 1) (x_0 2 y_0 2) to  (x_T 2 y_T 2) dots","category":"page"},{"location":"","page":"Home","title":"Home","text":"defined in a domain, the essential goal of Ulam's method is to partition the domain into a series of non-intersecting boxes and construct a transition probability matrix P on these boxes. In UlamMethod.jl, this is accomplished in two main steps","category":"page"},{"location":"","page":"Home","title":"Home","text":"The user provides a rectangle containing the data, and covering of the the domain is generated by polygons according to one of several different binning algorithms.\nThe number of trajectories beginning in polygon i and ending in polygon j is used to create the entry P_i j of P such that the edges of the domain are handled by a stochasticization algorithm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The polygons which form the covering and the transition probability matrix are the main outputs.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the Julia REPL, run the following code and follow the prompts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"UlamMethod\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Make the functions in this package available to use in your code by including the following line:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UlamMethod","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The core functionality is provided by ","category":"page"},{"location":"","page":"Home","title":"Home","text":"ulam_method(traj::UlamTrajectories, domain::UlamDomain)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where traj contains information about trajectories and domain contains information about the domain and covering. Here are 10000 random trajectories in the domain 0 10^2","category":"page"},{"location":"","page":"Home","title":"Home","text":"n_data = 10000\nx0, y0, xT, yT = 10*rand(n_data), 10*rand(n_data), 10*rand(n_data), 10*rand(n_data)\ntraj = UlamTrajectories(x0 = x0, y0 = y0, xT = xT, yT = yT)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We will take our domain to be the rectangular subset 3 5 times 4 8 and generate a covering with 40 squares.","category":"page"},{"location":"","page":"Home","title":"Home","text":"xmin, xmax, ymin, ymax = 3, 5, 4, 8\ndomain = UlamDomain(xmin, xmax, ymin, ymax, poly_type = \"sqr\", poly_number = 40)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Run Ulam's method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ulam = ulam_method(traj, domain)    # the main calculation\n\nulam.P_closed                       # the transition matrix\npt = PolyTable(ulam.polys)          # PolyTable makes a simple list of nodes and edges\npt.nodes                            # |x|y| table of polygon nodes\npt.edges[:,3]                       # the index of the polygon that the i'th node belongs to","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Ulam, Stanislaw M. A collection of mathematical problems. No. 8. Interscience Publishers, 1960.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Li, Tien-Yien. \"Finite approximation for the Frobenius-Perron operator. A solution to Ulam's conjecture.\" Journal of Approximation theory 17.2 (1976): 177-186.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: Reddy, Junuthula Narasimha. Introduction to the finite element method. McGraw-Hill Education, 2019.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4]: Miron, Philippe, et al. \"Transition paths of marine debris and the stability of the garbage patches<? A3B2 show [editpick]?>.\" Chaos: An Interdisciplinary Journal of Nonlinear Science 31.3 (2021): 033101.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[5]: Vanden-Eijnden, Eric. \"Transition path theory.\" Computer Simulations in Condensed Matter Systems: From Materials to Chemical Biology Volume 1. Springer, Berlin, Heidelberg, 2006. 453-493.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[6]: Lumpkin, Rick, and Mayra Pazos. \"Measuring surface currents with Surface Velocity Program drifters: the instrument, its data, and some recent results.\" Lagrangian analysis and prediction of coastal and ocean dynamics 39 (2007): 67.","category":"page"}]
}
