# Advanced Usage

## Loading trajectories

For larger systems, trajectory data may be loaded from a file. The core functionality is provided by 

```julia
UlamTrajectories(infile; x0_alias, y0_alias, xT_alias, yT_alias)
```

This file should be in the [.mat](https://github.com/JuliaIO/MAT.jl) or [.h5](https://github.com/JuliaIO/HDF5.jl) format with the keys `"x0"`, `"y0"`, `"xT"` and `"xT"` in the root of the file.  Aliases for the trajectory data may be provided. For example, if we had a file in which the `"x0"` data were instead called `"xtraj0"`, we could use `traj = UlamTrajectories(infile, x0_alias = "xtraj0")` and so on for other keys.

## Defining domains

The core functionality is provided by 

```julia
UlamDomain(domain; poly_type, poly_number, stoc_type, stoc_polygon, rseed)
```

The field `domain` should be an `UlamPolygon`. All data outside `domain` will be considered to be in _nirvana_.[^5] [^6] A convenience method is provided for rectangular domains:

```julia
UlamDomain(xmin, xmax, ymin, ymax; poly_type, poly_number, stoc_type, stoc_polygon, rseed)
```

This automatically constructs a rectangular domain with bottom left corner `(xmin, ymin)` and upper right corner `(xmax, ymax)`. In either case, the rectangular bounding box of the domain is automatically computed. Refer to `src/earth-polygons.jl` for some sample domains.

### [Binning Algorithms](@id binning)

These algorithms control how the computational rectangle (that is, the bounding box of the `domain`) is covered in polygons. The named argument `poly_type` to `UlamDomain` can take one of four values:

- `"rec"`: A covering of the domain by a regular grid of rectangles (default.) The rectangles cover the domain exactly and are constructed to be as close as possible to squares. 
- `"sqr"`: A covering of the domain by a regular grid of squares. The tradeoff for having perfect squares is that the domain iis not exactly covered, so squares near the edges may overlap.
- `"tri"`: A covering of the domain by a regular grid of equilateral triangles.
- `"hex"`: A covering of the domain by a regular grid of hexagons. Hexagons may have some advantages over rectangles [^1].
- `"vor"`: A covering of the domain by a Voronoi tesselation generated by cluster centers obtained from k-means [^2]. This algorithm is more appropriate for sparse data. Pass `rseed` for reproducible results; the k-means initialization contains some randomness.

The named argument `poly_number` selects the number of polygons in each case. This is the "initial" number of polygons. The actual number of polygons returned is generally less than `poly_number` since some polygons may not contain data or may be part of a disconnected set of states.

### [Stochasticization Algorithms](@id stoc)

These algorithms control how reinjection counts (trajectories pointing from nirvana to the interior) are distributed. The named argumet `stoc_type` to `UlamDomain` can take one of two values:

- `"data"`: Reinjection occurs according to which boxes trajectories actually enter (this is the default algorithm.)
- `"source"`: Reinjection occurs uniformly in polygons specified by `stoc_source`. If `stoc_source` is provided, `"source"` is automatically selected. If `"source"` is selected but no `stoc_source` is provided, then `stoc_source` is set equal to the `domain`. This is equivalent to reinjecting data uniformly across all boxes.
    - If `stoc_source` is entered as an $N \times 2$ matrix of numbers, then reinjection occurs at the set of polygons which contain at least one point from `stoc_source`.
    - If `stoc_source` is entered as an `UlamPolygon`, then reinjection occurs at the set of polygons which intersect `stoc_source`.

## Computing the main results

The core functionality is provided by 
```julia
ulam_method(traj, domain)
```
The output of `ulam_method` is an `UlamResult`. This contains the main objects calculated by Ulam's Method.

- `polys`: A vector of `UlamPolygon`s which define the covering. Use `PolyTable` to access the nodes in a readable format.
- `polys_dis`: A vector of `UlamPolygon`s which contained data but were disconnected when the strongest connected component was calculated.
- `P_closed`: The full transition matrix. The last row and column correspond to nirvana.
- `pi_closed`: The largest left eigenvector of `P_closed`.

For convenience `P_open` and `pi_open` are also provided, which are identical to `P_closed` and `pi_closed` with the nirvana entries removed.

## Writing the results

A custom write method is provided

```julia
ulam_write(outfile, ulam_result; dir_name, overwrite, P_out)
```

This will write an `UlamResult` to the file specified by `outfile`. Note that `outfile` must be of the form `"my_filename.h5"`. 

- `dir_name` is the name of the directory that the data are written to in `outfile`. The default is `dir_name = "ulam"`. The directory can be nested, e.g. `dir_name = "trial1/ulam"`.
- `overwrite` is a boolean such that a directory in `outfile` with the same name as `dir_name` will be overwritten with `ulam_result`. The default is `overwrite = false`.
- `P_out` is a boolean such that `P_closed` is written to the file if `P_out = true` (default). Consider using `P_out = false` if `P_closed` is not needed and smaller file size is desired.

The polygons will be output in an $N \times 3$ matrix such that the first two columns are the $(x, y)$ coordinates of a polygon vertex and the third column is the index of the polygon that vertex belongs to. The vertices are sorted. 

## Full workflow example

For this example, the file [`test/x0x5-NA-undrogued.h5`](https://github.com/70Gage70/UlamMethod.jl/blob/main/test/x0x5-NA-undrogued.h5) contains trajectory data from undrogued drifters in the North Atlantic obtained from the NOAA GDP [^3] [^4].

```julia
infile = "x0x5-NA-undrogued.h5"     # place this file in your working directory, or define a path to it
traj = UlamTrajectories(infile)
```

Next we define our domain. We'll use `North_Atlantic_clipped_verts` here. For the binning, we'll use the default rectangle covering `"rec"` with 760 polygons. We'll also use the default `"data"` stochasticization algorithm.

```julia
NA = UlamPolygon(North_Atlantic_clipped_verts)
poly_type = "rec"
poly_number = 760

domain = UlamDomain(NA, poly_type = poly_type, poly_number = poly_number)
```

The final step is to apply Ulam's method.

```julia
ulam = ulam_method(traj, domain)
```

From here, a `.h5` file can be created with `ulam_write("my_ulam_results.h5", ulam)` or `ulam` can be used elsewhere.

## References

[^1]: https://www.uber.com/blog/h3/

[^2]: https://juliastats.org/Clustering.jl/stable/kmeans.html#K-means

[^3]: https://www.aoml.noaa.gov/phod/gdp/data.php

[^4]: Lumpkin, Rick, and Mayra Pazos. "Measuring surface currents with Surface Velocity Program drifters: the instrument, its data, and some recent results." Lagrangian analysis and prediction of coastal and ocean dynamics 39 (2007): 67.

[^5]: Miron, Philippe, et al. "Transition paths of marine debris and the stability of the garbage patches." Chaos: An Interdisciplinary Journal of Nonlinear Science 31.3 (2021): 033101.

[^6]: In brief, nirvana is an extra state appended to an open system to close it; trajectories which point from inside the domain to the outisde of the domain transition to this nirvana state. Trajectories which point from outside the domain to the inside are transitions "from" nirvana - how exactly these data are reinjected is controlled by the [stochasticization algorithms](@ref stoc).