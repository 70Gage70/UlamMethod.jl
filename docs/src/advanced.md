# Advanced Usage

## Loading trajectories

The core functionality is provided by 
```julia
UlamTrajectories(infile; x0_alias, y0_alias, xT_alias, yT_alias)
```
For larger systems, trajectory data may be loaded from a file. This file should be in the [.mat](https://github.com/JuliaIO/MAT.jl) or [.h5](https://github.com/JuliaIO/HDF5.jl) format with the keys `"x0"`, `"y0"`, `"xT"` and `"xT"` in the root of the file. For this example, the file [`test/x0x5-NA-undrogued.h5`](https://github.com/70Gage70/UlamMethod.jl/blob/afba50ee715d0f8e35f98c70409d7807346f3fba/test/x0x5-NA-undrogued.h5) contains trajectory data from undrogued drifters in the North Atlantic obtained from the NOAA GDP [^3].
```julia
infile = "x0x5-NA-undrogued.h5"     # place this file in your working directory, or define a path to it
traj = UlamTrajectories(infile)
```
Alias for the trajectory data may be provided. For example, if we had a file in which the `"x0"` data were instead called `"xtraj0"`, we could use `traj = UlamTrajectories(infile, x0_alias = "xtraj0")` and so on for other keys.

## Defining domains

The core functionality is provided by 
```julia
UlamDomain(xmin, xmax, ymin, ymax; domain, poly_type, poly_number, stoc_type, stoc_polygon, rseed)
```

### Refinement

The default behavior is that all data outside the computational rectangle are considered to be in nirvana. The core computatinal rectangle can be refined with the named argument `domain`. This should be a single `UlamPolygon`. The effect `domain` is that data points inside the rectangle but outside the domain are considered to be in nirvana. _TODO: Add examples_.

### [Binning Algorithms](@id binning)

These algorithms control how the computational rectangle is covered in polygons. The named argument `poly_type` to `UlamDomain` can take one of three values:

- `"sqr"`: A covering of the domain by a regular grid of squares (default.) This algorithm is suitable for trajectory data with few "holes" in the observations.
- `"hex"`: A covering of the domain by a regular grid of hexagons. Hexagons may have some advantages over squares [^1].
- `"vor"`: A covering of the domain by a Voronoi tesselation generated by cluster centers obtained from k-means [^2]. This algorithm is more appropriate for sparse data. Pass `rseed` for reproducible results; the kmeans initialization contains some randomness.

The named argument `poly_number` selects the number of polygons in each case.

### [Stochasticization Algorithms](@id stoc)

These algorithms control how reinjection counts (trajectories pointing from nirvana to the interior) are distributed. The named argumet `stoc_type` to `UlamDomain` can take one of two values:

- `"data"`: Reinjection occurs according to which boxes trajectories actually enter (this is the default algorithm.)
- `"source"`: Reinjection occurs uniformly in polygons which intersect with the `UlamPolygon` in the named argument `stoc_poly`. If no `stoc_poly` is provided, reinjection occurs uniformly over the entire domain.

## Using the results

The core functionality is provided by 
```julia
ulam_method(traj, domain)
```
The output of `ulam_method` is an `UlamResult`. This contains the main objects calculated by Ulam's Method.

- `polys`: A vector of `UlamPolygon`s which define the covering. Use `PolyTable` to access the nodes in a readable format.
- `polys_dis`: A vector of `UlamPolygon`s which contained data but were disconnected when the strongest connected component was calculated.
- `P_closed`: The full transition matrix. The last row and column correspond to nirvana.
- `pi_closed`: The largest left eigenvector of `P_closed`.

For convenience `P_open` and `pi_open` are also provided, which are identical to `P_closed` and `pi_closed` with the nirvana entries removed.

## Writing the results

A custom write method is provided
```julia
ulam_write(outfile, ulam_result; P_out)
```
This will write an `UlamResult` to the file specified by `outfile`. Note that `outfile` must be of the form `"fname.h5"`. Optionally pass `P_out = false` to avoid writing the `P_closed` matrix since it can be very large.

The polygons will be output in an $N \times 3$ matrix such that the first two columns are the $(x, y)$ coordinates of a polygon vertex and the third column is the index of the polygon that vertex belongs to. The vertices are sorted. 

## References

[^1]: https://www.uber.com/blog/h3/

[^2]: https://juliastats.org/Clustering.jl/stable/kmeans.html#K-means

[^3]: https://www.aoml.noaa.gov/phod/gdp/data.php